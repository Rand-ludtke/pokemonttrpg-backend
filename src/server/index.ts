import express, { Request, Response } from "express";
import http from "http";
import { Server, Socket } from "socket.io";
import path from "path";
import fs from "fs";
import { v4 as uuidv4 } from "uuid";
import Engine from "../engine";
import SyncPSEngine from "../sync-ps-engine";
import { Action, MoveAction, SwitchAction, Player, TurnResult, BattleState } from "../types";
import { ExternalDexData } from "../adapters/pokedex-adapter";
import { mergeAbilities } from "../data/abilities";
import { mergeItems } from "../data/items";
import { convertShowdownAbilities, convertShowdownItems } from "../data/converters/showdown-converter";
import { convertShowdownSpecies, convertShowdownMoves } from "../data/converters/showdown-species-moves";

// Configuration: Use Pokemon Showdown engine (true) or custom engine (false)
const USE_PS_ENGINE = process.env.USE_PS_ENGINE !== "false"; // Default to PS engine

// Simple JSON persistence directories (for Raspberry Pi prototype)
const DATA_DIR = path.resolve(process.cwd(), "data");
const REPLAYS_DIR = path.join(DATA_DIR, "replays");
const CUSTOM_DEX_FILE = path.join(DATA_DIR, "customdex.json");
const CUSTOM_SPRITES_FILE = path.join(DATA_DIR, "customsprites.json");
if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR);
if (!fs.existsSync(REPLAYS_DIR)) fs.mkdirSync(REPLAYS_DIR);

export interface ClientInfo {
  id: string;
  username: string;
  trainerSprite?: string;
}

// Union type for either engine
type BattleEngine = Engine | SyncPSEngine;

export interface Room {
  id: string;
  name: string;
  players: { id: string; username: string; socketId: string; trainerSprite?: string }[];
  spectators: { id: string; username: string; socketId: string; trainerSprite?: string }[];
  engine?: BattleEngine;
  battleStarted: boolean;
  startProtocolSent?: boolean;
  turnBuffer: Record<string, Action>; // keyed by player id
  replay: any[];
  phase?: "normal" | "force-switch" | "team-preview";
  forceSwitchNeeded?: Set<string>;
  forceSwitchTimer?: NodeJS.Timeout;
  forceSwitchDeadline?: number; // epoch ms
  turnTimer?: NodeJS.Timeout;
  turnDeadline?: number; // epoch ms for turn timeout
  challenges: Map<string, Challenge>;
  lastPromptByPlayer?: Record<string, { turn: number; type: "move" | "wait" | "switch" | "team"; rqid?: number }>;
  // Team preview state
  teamPreviewPlayers?: Player[];
  teamPreviewOrders?: Record<string, number[]>;
  teamPreviewRules?: any;
}

type ChallengeStatus = "pending" | "launching" | "cancelled" | "declined";

interface ChallengeParticipant {
  playerId: string;
  username: string;
  socketId: string;
  accepted: boolean;
  trainerSprite?: string;
  playerPayload?: Player;
}

interface Challenge {
  id: string;
  roomId: string;
  createdAt: number;
  rules?: any;
  format?: string;
  status: ChallengeStatus;
  owner: ChallengeParticipant;
  target?: ChallengeParticipant;
  open: boolean;
}

interface ChallengeSummary {
  id: string;
  roomId: string;
  status: ChallengeStatus;
  createdAt: number;
  open: boolean;
  format?: string;
  rules?: any;
  owner: { id: string; username: string; accepted: boolean; ready: boolean };
  target?: { id: string; username: string; accepted: boolean; ready: boolean } | null;
}

const DEFAULT_LOBBY_ID = "global-lobby";
const DEFAULT_LOBBY_NAME = "Global Lobby";

function createRoomRecord(id: string, name: string): Room {
  return {
    id,
    name,
    players: [],
    spectators: [],
    engine: undefined,
    battleStarted: false,
    startProtocolSent: false,
    turnBuffer: {},
    replay: [],
    phase: "normal",
    teamPreviewPlayers: undefined,
    teamPreviewOrders: undefined,
    teamPreviewRules: undefined,
    forceSwitchNeeded: new Set(),
    forceSwitchTimer: undefined,
    forceSwitchDeadline: undefined,
    turnTimer: undefined,
    turnDeadline: undefined,
    challenges: new Map(),
    lastPromptByPlayer: {},
  };
}

function challengeSummary(ch: Challenge): ChallengeSummary {
  return {
    id: ch.id,
    roomId: ch.roomId,
    status: ch.status,
    createdAt: ch.createdAt,
    open: ch.open && !ch.target,
    format: ch.format,
    rules: ch.rules,
    owner: {
      id: ch.owner.playerId,
      username: ch.owner.username,
      accepted: ch.owner.accepted,
      ready: Boolean(ch.owner.playerPayload),
    },
    target: ch.target
      ? {
          id: ch.target.playerId,
          username: ch.target.username,
          accepted: ch.target.accepted,
          ready: Boolean(ch.target.playerPayload),
        }
      : null,
  };
}

function challengeSummaries(room: Room): ChallengeSummary[] {
  return Array.from(room.challenges.values()).map(challengeSummary);
}

function findPlayerBySocket(room: Room, socketId: string) {
  return room.players.find((p) => p.socketId === socketId);
}

function findSpectatorBySocket(room: Room, socketId: string) {
  return room.spectators.find((s) => s.socketId === socketId);
}

function removeClientFromRoom(room: Room, socketId: string) {
  const playersBefore = room.players.length;
  room.players = room.players.filter((p) => p.socketId !== socketId);
  const spectatorsBefore = room.spectators.length;
  room.spectators = room.spectators.filter((s) => s.socketId !== socketId);
  return playersBefore !== room.players.length || spectatorsBefore !== room.spectators.length;
}

const app = express();

// Enable CORS for all API routes
app.use((_req, res, next) => {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
  res.header("Access-Control-Allow-Headers", "Content-Type, Authorization");
  if (_req.method === "OPTIONS") {
    return res.sendStatus(200);
  }
  next();
});

app.use(express.json({ limit: "25mb" }));

// --- Custom Dex persistence & helpers ---
type SpriteSlot = "front" | "shiny" | "back" | "back-shiny";
type CustomSpritesData = Record<string, Partial<Record<SpriteSlot, string>>>;
type CustomSyncPayload = ExternalDexData & { sprites?: CustomSpritesData };

function loadCustomDex(): ExternalDexData {
  try {
    if (fs.existsSync(CUSTOM_DEX_FILE)) {
      const json = JSON.parse(fs.readFileSync(CUSTOM_DEX_FILE, "utf-8"));
      // Ensure shape
      return { species: json.species ?? {}, moves: json.moves ?? {} } as ExternalDexData;
    }
  } catch {}
  return { species: {}, moves: {} };
}

function saveCustomDex(dex: ExternalDexData) {
  const payload = { species: dex.species ?? {}, moves: dex.moves ?? {} };
  fs.writeFileSync(CUSTOM_DEX_FILE, JSON.stringify(payload, null, 2));
}

function loadCustomSprites(): CustomSpritesData {
  try {
    if (fs.existsSync(CUSTOM_SPRITES_FILE)) {
      const json = JSON.parse(fs.readFileSync(CUSTOM_SPRITES_FILE, "utf-8"));
      return (json && typeof json === "object") ? json : {};
    }
  } catch {}
  return {};
}

function saveCustomSprites(sprites: CustomSpritesData) {
  const payload = sprites ?? {};
  fs.writeFileSync(CUSTOM_SPRITES_FILE, JSON.stringify(payload, null, 2));
}

function diffDex(serverDex: ExternalDexData, clientDex: ExternalDexData) {
  const missingOnClient = { species: {} as Record<string, any>, moves: {} as Record<string, any> };
  const missingOnServer = { species: {} as Record<string, any>, moves: {} as Record<string, any> };

  // Server -> Client (what client lacks)
  for (const [id, s] of Object.entries(serverDex.species ?? {})) {
    if (!clientDex.species || !clientDex.species[id]) missingOnClient.species[id] = s;
  }
  for (const [id, m] of Object.entries(serverDex.moves ?? {})) {
    if (!clientDex.moves || !clientDex.moves[id]) missingOnClient.moves[id] = m;
  }

  // Client -> Server (what server lacks)
  for (const [id, s] of Object.entries(clientDex.species ?? {})) {
    if (!serverDex.species || !serverDex.species[id]) missingOnServer.species[id] = s;
  }
  for (const [id, m] of Object.entries(clientDex.moves ?? {})) {
    if (!serverDex.moves || !serverDex.moves[id]) missingOnServer.moves[id] = m;
  }

  return { missingOnClient, missingOnServer };
}

function diffSprites(serverSprites: CustomSpritesData, clientSprites: CustomSpritesData) {
  const missingOnClient: CustomSpritesData = {};
  const missingOnServer: CustomSpritesData = {};

  for (const [id, slots] of Object.entries(serverSprites || {})) {
    for (const [slot, dataUrl] of Object.entries(slots || {})) {
      if (!dataUrl) continue;
      const existing = clientSprites?.[id]?.[slot as SpriteSlot];
      if (!existing) {
        missingOnClient[id] = { ...(missingOnClient[id] || {}), [slot]: dataUrl } as any;
      }
    }
  }

  for (const [id, slots] of Object.entries(clientSprites || {})) {
    for (const [slot, dataUrl] of Object.entries(slots || {})) {
      if (!dataUrl) continue;
      const existing = serverSprites?.[id]?.[slot as SpriteSlot];
      if (!existing) {
        missingOnServer[id] = { ...(missingOnServer[id] || {}), [slot]: dataUrl } as any;
      }
    }
  }

  return { missingOnClient, missingOnServer };
}

app.get("/api/rooms", (_req: Request, res: Response) => {
  const list = Array.from(rooms.values()).map((r) => ({
    id: r.id,
    name: r.name,
    players: r.players.map((p) => p.username),
    spectCount: r.spectators.length,
    started: r.battleStarted,
    challengeCount: r.challenges.size,
  }));
  res.json(list);
});

// Custom Dex APIs
// 1) Read server-side store
app.get("/api/customdex", (_req: Request, res: Response) => {
  const dex = loadCustomDex();
  res.json(dex);
});

// 2) Sync: client posts its dex; server returns what client is missing (from server),
//    and what server is missing (from client). Client may then call /upload to add to server.
app.post("/api/customdex/sync", (req: Request, res: Response) => {
  const clientDex = (req.body ?? {}) as CustomSyncPayload;
  const serverDex = loadCustomDex();
  const serverSprites = loadCustomSprites();
  const clientSprites = clientDex.sprites || {};
  const { missingOnClient, missingOnServer } = diffDex(serverDex, clientDex);
  const spriteDiff = diffSprites(serverSprites, clientSprites);
  res.json({
    missingOnClient: { ...missingOnClient, sprites: spriteDiff.missingOnClient },
    missingOnServer: { ...missingOnServer, sprites: spriteDiff.missingOnServer },
  });
});

// 3) Upload: merge new entries from client into server store (no overwrite by default)
app.post("/api/customdex/upload", (req: Request, res: Response) => {
  const incoming = (req.body ?? {}) as CustomSyncPayload;
  const serverDex = loadCustomDex();
  const serverSprites = loadCustomSprites();
  let addedSpecies = 0;
  let addedMoves = 0;
  let addedSprites = 0;
  serverDex.species = serverDex.species || {};
  serverDex.moves = serverDex.moves || {};
  for (const [id, s] of Object.entries(incoming.species ?? {})) {
    if (!serverDex.species[id]) {
      serverDex.species[id] = s as any;
      addedSpecies++;
    }
  }
  for (const [id, m] of Object.entries(incoming.moves ?? {})) {
    if (!serverDex.moves[id]) {
      serverDex.moves[id] = m as any;
      addedMoves++;
    }
  }
  for (const [id, slots] of Object.entries(incoming.sprites || {})) {
    const slotMap = slots as Record<string, string>;
    for (const [slot, dataUrl] of Object.entries(slotMap || {})) {
      if (!dataUrl) continue;
      const existing = serverSprites?.[id]?.[slot as SpriteSlot];
      if (!existing) {
        serverSprites[id] = { ...(serverSprites[id] || {}), [slot]: dataUrl } as any;
        addedSprites++;
      }
    }
  }
  saveCustomDex(serverDex);
  saveCustomSprites(serverSprites);
  res.json({ ok: true, added: { species: addedSpecies, moves: addedMoves, sprites: addedSprites } });
});

app.get("/api/rooms/:id", (req: Request, res: Response) => {
  const room = rooms.get(req.params.id);
  if (!room) return res.status(404).json({ error: "room not found" });
  res.json({
    id: room.id,
    name: room.name,
    players: room.players.map((p) => ({ id: p.id, username: p.username })),
    spectCount: room.spectators.length,
    started: room.battleStarted,
    challengeCount: room.challenges.size,
  });
});

app.get("/api/replay/:id", (req: Request, res: Response) => {
  const file = path.join(REPLAYS_DIR, `${req.params.id}.json`);
  if (!fs.existsSync(file)) return res.status(404).send("Replay not found");
  res.download(file);
});
app.get("/api/replays", (_req: Request, res: Response) => {
  const files = fs.readdirSync(REPLAYS_DIR).filter(f => f.endsWith('.json'));
  const list = files.map(f => ({ id: f.replace(/\.json$/, ''), size: fs.statSync(path.join(REPLAYS_DIR, f)).size }));
  res.json(list);
});
app.get("/api/replays/:id/meta", (req: Request, res: Response) => {
  const file = path.join(REPLAYS_DIR, `${req.params.id}.json`);
  if (!fs.existsSync(file)) return res.status(404).json({ error: "not found" });
  const json = JSON.parse(fs.readFileSync(file, "utf-8"));
  res.json({ id: json.id, room: json.room, createdAt: json.createdAt, turns: json.replay?.length ?? 0 });
});

// Compact spectator snapshot: mirrors spectate_start payload
app.get("/api/rooms/:id/snapshot", (req: Request, res: Response) => {
  const room = rooms.get(req.params.id);
  if (!room || !room.engine) return res.status(404).json({ error: "room not found or battle not started" });
  const needsSwitch = room.forceSwitchNeeded ? Array.from(room.forceSwitchNeeded) : [];
  const state = room.engine.getState();
  res.json({ state, replay: room.replay, phase: room.phase ?? "normal", needsSwitch, deadline: room.forceSwitchDeadline ?? null, rooms: { trick: state.field.room, magic: state.field.magicRoom, wonder: state.field.wonderRoom } });
});

const server = http.createServer(app);
const io = new Server(server, { cors: { origin: "*" } });

process.on("uncaughtException", (err) => {
  console.error("[Server] Uncaught exception:", err?.stack || err);
});

process.on("unhandledRejection", (err) => {
  console.error("[Server] Unhandled rejection:", err);
});

function emitChallengeCreated(room: Room, challenge: Challenge) {
  io.to(room.id).emit("challengeCreated", { roomId: room.id, challenge: challengeSummary(challenge) });
}

function emitChallengeUpdated(room: Room, challenge: Challenge) {
  io.to(room.id).emit("challengeUpdated", { roomId: room.id, challenge: challengeSummary(challenge) });
}

function emitChallengeRemoved(room: Room, challengeId: string, reason: string) {
  io.to(room.id).emit("challengeRemoved", { roomId: room.id, challengeId, reason });
}

function coerceTrainerSprite(value: unknown): string | undefined {
  let raw: string | undefined;
  if (typeof value === "string") {
    raw = value.trim();
  } else if (typeof value === "number" && Number.isFinite(value)) {
    raw = String(Math.trunc(value));
  }
  if (!raw) return undefined;
  // Normalize: lowercase, remove spaces/special chars
  const normalized = raw.toLowerCase().replace(/[\s_-]+/g, "").replace(/[^a-z0-9]/gi, "");
  // Filter out invalid/placeholder values
  const invalid = ["pending", "random", "default", "unknown", "none", ""];
  if (invalid.includes(normalized)) return undefined;
  return raw;
}

function sanitizePlayerPayload(player: Player, participant: ChallengeParticipant): Player {
  const clone = JSON.parse(JSON.stringify(player)) as Player;
  const cloneAny = clone as any;
  const trainerSprite = coerceTrainerSprite(
    cloneAny.trainerSprite ?? cloneAny.avatar ?? participant.trainerSprite
  );
  clone.id = participant.playerId;
  clone.name = clone.name || participant.username;
  if (typeof clone.activeIndex !== "number") clone.activeIndex = 0;
  // Always set/clear trainerSprite and avatar to ensure invalid values are removed
  cloneAny.trainerSprite = trainerSprite || undefined;
  cloneAny.avatar = trainerSprite || undefined;
  return clone;
}

function startTeamPreview(room: Room, players: Player[], rules?: any) {
  room.phase = "team-preview";
  room.teamPreviewPlayers = players;
  room.teamPreviewOrders = {};
  room.teamPreviewRules = rules;
  
  // Emit teamPreviewStarted FIRST so client can mount the battle tab before receiving prompts
  io.to(room.id).emit("teamPreviewStarted", { roomId: room.id });
  
  // Send team preview request to each player (after tab is mounted)
  for (let i = 0; i < players.length; i++) {
    const player = players[i];
    const playerSocket = room.players.find(p => p.id === player.id)?.socketId;
    if (!playerSocket) continue;
    const sock = io.sockets.sockets.get(playerSocket);
    if (!sock) continue;
    
    // Find opponent(s) for team preview display
    const opponents = players.filter((p, idx) => idx !== i);
    
    const maxTeamSize = rules?.maxTeamSize || Math.min(6, player.team.length);
    sock.emit("promptAction", {
      roomId: room.id,
      requestType: "teampreview",
      playerId: player.id,
      side: `p${i + 1}`,
      prompt: {
        teamPreview: true,
        maxTeamSize,
        side: {
          id: `p${i + 1}`,
          name: player.name || player.id,
          pokemon: player.team.map((p: any, idx: number) => ({
            id: p.id,
            pokemonId: p.id,
            ident: `p${i + 1}: ${p.name || p.species}`,
            details: `${p.species}, L${p.level || 50}`,
            condition: `${p.currentHP || p.stats?.hp || 100}/${p.stats?.hp || 100}`,
            active: idx === 0,
            stats: p.stats,
            moves: p.moves,
            baseAbility: p.ability,
            item: p.item,
            pokeball: p.pokeball || "pokeball",
          })),
        },
      },
      // Include all players' teams so opponent can be displayed
      state: {
        players: players.map((p, pIdx) => ({
          id: p.id,
          name: p.name || p.id,
          trainerSprite: (p as any).trainerSprite,
          avatar: (p as any).avatar ?? (p as any).trainerSprite,
          activeIndex: 0,
          team: p.team.map((mon: any) => ({
            id: mon.id,
            pokemonId: mon.id,
            // Use mon.name as the species (in our type system, 'name' IS the species, 'nickname' is for display)
            name: mon.nickname || mon.name || mon.species,
            species: mon.species || mon.name, // Ensure species is always set
            nickname: mon.nickname,
            level: mon.level || 50,
            types: mon.types,
            gender: mon.gender,
            shiny: mon.shiny,
            item: mon.item,
          })),
        })),
      },
    });
  }
}

function applyTeamOrder(player: Player, order: number[]): Player {
  if (!order || !order.length) return player;
  const clone = JSON.parse(JSON.stringify(player)) as Player;
  const newTeam: any[] = [];
  for (const slot of order) {
    const idx = slot - 1; // order is 1-based
    if (idx >= 0 && idx < clone.team.length) {
      newTeam.push(clone.team[idx]);
    }
  }
  // Add any remaining Pokemon not in the order
  for (let i = 0; i < clone.team.length; i++) {
    if (!order.includes(i + 1)) {
      newTeam.push(clone.team[i]);
    }
  }
  clone.team = newTeam;
  clone.activeIndex = 0;
  return clone;
}

function checkTeamPreviewComplete(room: Room) {
  console.log(`[checkTeamPreviewComplete] phase=${room.phase}, hasPlayers=${!!room.teamPreviewPlayers}, hasOrders=${!!room.teamPreviewOrders}`);
  if (room.phase !== "team-preview" || !room.teamPreviewPlayers || !room.teamPreviewOrders) return;
  
  console.log(`[checkTeamPreviewComplete] Players:`, room.teamPreviewPlayers.map(p => p.id));
  console.log(`[checkTeamPreviewComplete] Orders submitted:`, Object.keys(room.teamPreviewOrders));
  
  const allSubmitted = room.teamPreviewPlayers.every(p => room.teamPreviewOrders![p.id]);
  console.log(`[checkTeamPreviewComplete] allSubmitted=${allSubmitted}`);
  if (!allSubmitted) return;
  
  // Apply team orders and start the battle
  const orderedPlayers = room.teamPreviewPlayers.map(player => {
    const order = room.teamPreviewOrders![player.id];
    return applyTeamOrder(player, order);
  });
  
  // Clear team preview state
  room.teamPreviewPlayers = undefined;
  room.teamPreviewOrders = undefined;
  const rules = room.teamPreviewRules;
  room.teamPreviewRules = undefined;
  
  // Start the actual battle
  beginBattle(room, orderedPlayers, rules?.seed);
}

function beginBattle(room: Room, players: Player[], seed?: number, rules?: any) {
  try {
  // Check if team preview is enabled
  if (rules?.teamPreview && room.phase !== "team-preview") {
    startTeamPreview(room, players, rules);
    return;
  }
  
  const battleSeed = Number.isFinite(seed as number) ? (seed as number) : undefined;
  
  // Use Pokemon Showdown engine or custom engine based on configuration
  if (USE_PS_ENGINE) {
    console.log(`[Server] Using Pokemon Showdown battle engine with rules:`, JSON.stringify(rules));
    room.engine = new SyncPSEngine({ format: "gen9customgame", seed: battleSeed, rules });
  } else {
    console.log(`[Server] Using custom battle engine`);
    room.engine = new Engine({ seed: battleSeed });
  }
  
  room.turnBuffer = {};
  room.replay = [];
  clearForceSwitchTimer(room);
  const hydratedPlayers = players.map((player) => {
    const clone = JSON.parse(JSON.stringify(player)) as Player;
    const roomPlayer = room.players.find((p) => p.id === player.id);
    const trainerSprite = coerceTrainerSprite((clone as any).trainerSprite ?? (clone as any).avatar ?? roomPlayer?.trainerSprite);
    // Always set/clear trainerSprite and avatar to ensure invalid values are removed
    (clone as any).trainerSprite = trainerSprite || undefined;
    (clone as any).avatar = trainerSprite || undefined;
    return clone;
  });

  const state = room.engine.initializeBattle(hydratedPlayers, { seed: battleSeed });
  // Ensure clients treat this as turn 1 when prompting (no pre-start move UI)
  if (typeof state.turn === "number" && state.turn < 1) {
    state.turn = 1;
  }
  room.battleStarted = true;
  room.phase = "normal";
  room.forceSwitchNeeded = new Set();
  console.log(`[Server] Emitting battleStarted for room ${room.id}`);
  io.to(room.id).emit("battleStarted", { roomId: room.id, state });

  // Emit initial protocol events (|start|, |switch|, |turn|1) before prompting for moves
  // This prevents a pre-start move prompt from showing before the battle is visually started.
  // ONLY do this if the engine hasn't already generated start events (SyncPSEngine now does)
  const hasStart = Array.isArray(state.log) && state.log.some((l: string) => l.startsWith("|start"));
  if (hasStart) room.startProtocolSent = true;
  
  if (!hasStart) {
    const initialEvents = buildInitialBattleProtocol(state);
    if (initialEvents.length > 0) {
      // Append to state.log so SyncPSEngine won't re-send these lines later
      if (Array.isArray(state.log)) {
        for (const line of initialEvents) {
          if (!state.log.includes(line)) state.log.push(line);
        }
      }
      room.startProtocolSent = true;
      io.to(room.id).emit("battleUpdate", {
        result: { state, events: initialEvents, anim: [] },
        needsSwitch: Array.from(room.forceSwitchNeeded ?? []),
      });
    }
  }
  
  // Emit move prompts to each player so they can choose their first action
  emitMovePrompts(room, state);
  } catch (err: any) {
    console.error(`[Server] beginBattle failed for room ${room.id}:`, err?.stack || err);
    room.engine = undefined;
    room.battleStarted = false;
    room.startProtocolSent = false;
    room.phase = "normal";
    room.turnBuffer = {};
    room.forceSwitchNeeded = new Set();
    io.to(room.id).emit("battleStartError", {
      roomId: room.id,
      message: err?.message || "Failed to start battle",
    });
  }
}

function buildInitialBattleProtocol(state: BattleState): string[] {
  if (!state?.players?.length) return [];
  const lines: string[] = [];
  lines.push("|start");
  state.players.forEach((player: any, idx: number) => {
    const side = `p${idx + 1}`;
    const activeIndex = player.activeIndex || 0;
    const activePoke = player.team?.[activeIndex];
    if (!activePoke) return;
    const nickname = activePoke.nickname || activePoke.name;
    const species = activePoke.species || activePoke.name;
    const level = activePoke.level || 100;
    const gender = activePoke.gender === "M" ? ", M" : (activePoke.gender === "F" ? ", F" : "");
    const shiny = (activePoke as any).shiny ? ", shiny" : "";
    const hp = activePoke.currentHP ?? activePoke.maxHP ?? 100;
    const maxHP = activePoke.maxHP ?? 100;
    const details = `${species}, L${level}${gender}${shiny}`;
    lines.push(`|switch|${side}a: ${nickname}|${details}|${hp}/${maxHP}`);
  });
  const turn = state.turn || 1;
  lines.push(`|turn|${turn}`);
  return lines;
}

// Deduplicate consecutive identical switch/drag lines (PS protocol sends private + public copies)
// Also deduplicate repeated switch events for the same slot within the same turn batch
function deduplicateSwitchLines(events: string[]): string[] {
  const result: string[] = [];
  const seenSwitches = new Set<string>();
  const seenSwitchTargets = new Map<string, string>(); // slot -> pokemon name
  
  for (let i = 0; i < events.length; i++) {
    const line = events[i];
    
    // Skip |split| lines entirely - they're PS internal markers
    if (line.startsWith('|split|')) {
      continue;
    }
    
    // Check if this is a switch/drag line
    if (line.startsWith('|switch|') || line.startsWith('|drag|') || line.startsWith('|replace|')) {
      // Extract just the identity part (e.g., "p1a: Typhlosion") to compare
      const parts = line.split('|');
      const ident = parts[2] || ''; // e.g., "p1a: Typhlosion"
      
      // Extract slot (e.g., "p1a") and pokemon name from ident
      const identMatch = ident.match(/^(p[12][a-z]?):\s*(.+)$/);
      if (identMatch) {
        const slot = identMatch[1];
        const pokeName = identMatch[2].trim();
        
        // Skip if we've already seen a switch to this SAME Pokemon on this SAME slot
        // (This catches duplicate switch events like "Go! Charizard!" appearing twice)
        const prevPoke = seenSwitchTargets.get(slot);
        if (prevPoke && prevPoke.toLowerCase() === pokeName.toLowerCase()) {
          console.log(`[deduplicateSwitchLines] Skipping duplicate switch: ${slot} -> ${pokeName}`);
          continue;
        }
        seenSwitchTargets.set(slot, pokeName);
      }
      
      // Skip if we've already seen this exact switch line in this batch
      if (seenSwitches.has(ident)) {
        continue;
      }
      seenSwitches.add(ident);
    }
    
    result.push(line);
  }
  
  return result;
}

// Emit move prompts to all players in a battle
function emitMovePrompts(room: Room, state: BattleState) {
  if (!room.engine) return;
  const turn = state.turn || 1;
  if (!room.lastPromptByPlayer) room.lastPromptByPlayer = {};
  
  // Start turn timer when prompts are sent (if not already in a waiting state)
  if (Object.keys(room.turnBuffer).length === 0) {
    startTurnTimer(room);
    console.log(`[Server] Turn timer started for room ${room.id} turn ${turn} (${TURN_TIMEOUT_MS}ms)`);
  }
  
  const promptedPlayers: string[] = [];
  const skippedPlayers: { id: string; reason: string }[] = [];
  
  for (const player of state.players) {
    const candidateSockets = room.players.filter((p) => p.id === player.id).map((p) => p.socketId);
    const playerSocket = candidateSockets.find((id) => io.sockets.sockets.has(id));
    if (!playerSocket) {
      skippedPlayers.push({ id: player.id, reason: "no valid socket" });
      continue;
    }
    const sock = io.sockets.sockets.get(playerSocket);
    if (!sock) {
      skippedPlayers.push({ id: player.id, reason: "socket not found" });
      continue;
    }
    
    const active = player.team[player.activeIndex];
    if (!active || active.currentHP <= 0) {
      skippedPlayers.push({ id: player.id, reason: "active fainted" });
      continue;
    }
    const alreadyActed = !!room.turnBuffer[player.id];
    
    promptedPlayers.push(player.id);
    
    // Get the PS engine's native request - this has the correct pokemon array ordering
    // PS reorders the pokemon array after switches so active is always at index 0
    let psRequest: any = null;
    if (room.engine instanceof SyncPSEngine) {
      psRequest = room.engine.getRequest(player.id);
    }
    
    const sideIndex = state.players.indexOf(player);
    const sideId = `p${sideIndex + 1}`;
    
    // If we have a PS request, use it directly - it has correct array ordering and PP
    if (psRequest && psRequest.side) {
      // PS request already has the correct format, just add our extra fields
      const baseSide = {
        ...psRequest.side,
        playerId: player.id,
      };

      const promptType: "move" | "wait" = alreadyActed ? "wait" : "move";
      const lastPrompt = room.lastPromptByPlayer[player.id];
      if (lastPrompt && lastPrompt.turn === turn && lastPrompt.type === promptType) {
        continue;
      }

      const prompt = alreadyActed
        ? { wait: true, side: baseSide, rqid: psRequest.rqid || Date.now() }
        : {
            ...psRequest,
            requestType: psRequest.requestType || "move",
            playerId: player.id,
            rqid: psRequest.rqid || Date.now(),
            // Ensure side has our player ID for reference
            side: baseSide,
          };
      
      sock.emit("promptAction", {
        roomId: room.id,
        playerId: player.id,
        prompt,
        state: state,
      });

      room.lastPromptByPlayer[player.id] = {
        turn,
        type: promptType,
        rqid: (prompt as any).rqid,
      };
      continue;
    }
    
    // Fallback: Build request manually if PS request not available
    // Note: This won't have the correct pokemon ordering after switches
    const psActiveMoves = psRequest?.active?.[0]?.moves || [];
    
    // Also try to get PP data directly from PS engine as a backup
    let engineMovesPP: Array<{ id: string; name: string; pp: number; maxpp: number; target: string; disabled: boolean }> | null = null;
    if (room.engine instanceof SyncPSEngine && psActiveMoves.length === 0) {
      engineMovesPP = room.engine.getActiveMovesPP(player.id);
      console.log(`[Server] Using engineMovesPP fallback for ${player.id}:`, engineMovesPP);
    }
    
    const sidePayload = {
        id: sideId,
        name: player.name || player.id,
        playerId: player.id,
        pokemon: player.team.map((p: any, idx: number) => ({
          id: p.id,
          pokemonId: p.id,
          ident: `${sideId}: ${p.name}`,
          details: `${p.species}, L${p.level}`,
          condition: p.currentHP <= 0 ? '0 fnt' : `${p.currentHP}/${p.stats?.hp || p.maxHP || 100}`,
          active: idx === player.activeIndex,
          stats: p.stats,
          moves: (p.moves || []).map((m: any) => typeof m === 'string' ? m : m.id || m.name),
          baseAbility: p.ability,
          item: p.item || '',
          pokeball: 'pokeball',
          ability: p.ability,
          fainted: p.currentHP <= 0,
        })),
    };

    const promptType: "move" | "wait" = alreadyActed ? "wait" : "move";
    const lastPrompt = room.lastPromptByPlayer[player.id];
    if (lastPrompt && lastPrompt.turn === turn && lastPrompt.type === promptType) {
      continue;
    }

    const prompt = alreadyActed
      ? { wait: true, side: sidePayload, rqid: Date.now() }
      : {
          requestType: "move" as const,
          side: sidePayload,
          playerId: player.id,
          rqid: Date.now(),
          active: [{
            moves: (active.moves || []).map((move: any, idx: number) => {
              const moveId = typeof move === "string" ? move : move.id || move.name || `move${idx}`;
              const normalizedMoveId = moveId.toLowerCase().replace(/[^a-z0-9]/g, "");
              
              // Try to find PP from multiple sources:
              // 1. psActiveMoves from activeRequest
              // 2. engineMovesPP from direct PS engine query
              // 3. Fall back to defaults
              const psMove = psActiveMoves.find((m: any) => m.id === normalizedMoveId || m.id === moveId);
              const engineMove = engineMovesPP?.find((m: any) => m.id === normalizedMoveId || m.id === moveId);
              
              const pp = psMove?.pp ?? engineMove?.pp ?? move.pp ?? 10;
              const maxpp = psMove?.maxpp ?? engineMove?.maxpp ?? move.maxpp ?? pp;
              
              return {
                move: typeof move === "string" ? move : move.name || move.id || `Move ${idx + 1}`,
                id: normalizedMoveId,
                pp,
                maxpp,
                target: psMove?.target ?? engineMove?.target ?? move.target ?? "normal",
                disabled: psMove?.disabled ?? engineMove?.disabled ?? move.disabled ?? false,
              };
            }),
          }],
        };
    
    sock.emit("promptAction", {
      roomId: room.id,
      playerId: player.id,
      prompt,
      state: state,
    });

    room.lastPromptByPlayer[player.id] = {
      turn,
      type: promptType,
      rqid: (prompt as any).rqid,
    };
  }
  
  console.log(`[Server] emitMovePrompts turn=${turn}: prompted=${JSON.stringify(promptedPlayers)} skipped=${JSON.stringify(skippedPlayers)}`);
}

// Emit force-switch prompts to players who need to switch due to fainted Pokemon
function emitForceSwitchPrompts(room: Room, state: BattleState, needsSwitch: string[]) {
  console.log(`[Server] emitForceSwitchPrompts called for ${needsSwitch.length} players:`, needsSwitch);
  for (const playerId of needsSwitch) {
    const playerSocket = room.players.find(p => p.id === playerId)?.socketId;
    if (!playerSocket) {
      console.log(`[Server] emitForceSwitchPrompts: No socket found for player ${playerId}`);
      continue;
    }
    const sock = io.sockets.sockets.get(playerSocket);
    if (!sock) {
      console.log(`[Server] emitForceSwitchPrompts: Socket not connected for player ${playerId}`);
      continue;
    }
    
    const player = state.players.find(p => p.id === playerId);
    if (!player) {
      console.log(`[Server] emitForceSwitchPrompts: Player not found in state for ${playerId}`);
      continue;
    }
    
    // Get the PS engine's native request - it has correctly ordered pokemon array
    let psRequest: any = null;
    if (room.engine instanceof SyncPSEngine) {
      psRequest = room.engine.getRequest(playerId);
      console.log(`[Server] emitForceSwitchPrompts: Got PS request for ${playerId}:`, JSON.stringify(psRequest?.forceSwitch));
    }
    
    const sideIndex = state.players.indexOf(player);
    const sideId = `p${sideIndex + 1}`;
    
    // If we have a PS request with forceSwitch, use it directly
    if (psRequest && psRequest.forceSwitch && psRequest.side) {
      const switchRequest = {
        ...psRequest,
        playerId: player.id,
        side: {
          ...psRequest.side,
          playerId: player.id,
        },
      };
      
      console.log(`[Server] emitForceSwitchPrompts: Emitting PS forceSwitch prompt to ${playerId}:`, {
        roomId: room.id,
        forceSwitch: switchRequest.forceSwitch,
        sidePokemon: switchRequest.side?.pokemon?.length,
      });
      sock.emit("promptAction", {
        roomId: room.id,
        playerId: player.id,
        prompt: switchRequest,
        state: state,
      });
      continue;
    }
    
    // Fallback: Build request manually if PS request not available
    const switchRequest = {
      forceSwitch: [true], // Single slot
      side: {
        id: sideId,
        name: player.name,
        playerId: player.id,
        pokemon: player.team.map((p: any, idx: number) => ({
          id: p.id,
          pokemonId: p.id,
          ident: `${sideId}: ${p.name}`,
          details: `${p.species}, L${p.level}`,
          condition: p.currentHP <= 0 ? '0 fnt' : `${p.currentHP}/${p.stats?.hp || p.maxHP || 100}`,
          active: idx === player.activeIndex,
          stats: p.stats,
          moves: (p.moves || []).map((m: any) => typeof m === 'string' ? m : m.id || m.name),
          baseAbility: p.ability,
          item: p.item || '',
          pokeball: 'pokeball',
          ability: p.ability,
          fainted: p.currentHP <= 0,
        })),
      },
      playerId: player.id,
    };
    
    sock.emit("promptAction", {
      roomId: room.id,
      playerId: player.id,
      prompt: switchRequest,
      state: state,
    });
  }
}

function broadcastRoomSummary(room: Room) {
  io.emit("roomUpdate", summary(room));
}

function launchChallenge(sourceRoom: Room, challenge: Challenge) {
  if (!challenge.target) {
    emitChallengeRemoved(sourceRoom, challenge.id, "no-opponent");
    sourceRoom.challenges.delete(challenge.id);
    return;
  }
  if (!challenge.owner.playerPayload || !challenge.target.playerPayload) {
    emitChallengeRemoved(sourceRoom, challenge.id, "missing-team");
    sourceRoom.challenges.delete(challenge.id);
    return;
  }

  const ownerSocket = io.sockets.sockets.get(challenge.owner.socketId);
  const targetSocket = io.sockets.sockets.get(challenge.target.socketId);
  if (!ownerSocket || !targetSocket) {
    emitChallengeRemoved(sourceRoom, challenge.id, "socket-disconnected");
    sourceRoom.challenges.delete(challenge.id);
    return;
  }

  const battleRoomId = uuidv4().slice(0, 8);
  const nameTokens: string[] = [];
  if (challenge.format) nameTokens.push(challenge.format);
  nameTokens.push(`${challenge.owner.username} vs ${challenge.target.username}`);
  const battleRoomName = `Battle: ${nameTokens.join(" â€¢ ")}`;
  const battleRoom = createRoomRecord(battleRoomId, battleRoomName);
  rooms.set(battleRoomId, battleRoom);

  ownerSocket.join(battleRoomId);
  targetSocket.join(battleRoomId);

  const ownerTrainerSprite = coerceTrainerSprite(
    (challenge.owner.playerPayload as any)?.trainerSprite ?? (challenge.owner.playerPayload as any)?.avatar ?? challenge.owner.trainerSprite
  );
  const targetTrainerSprite = coerceTrainerSprite(
    (challenge.target.playerPayload as any)?.trainerSprite ?? (challenge.target.playerPayload as any)?.avatar ?? challenge.target.trainerSprite
  );
  battleRoom.players.push({ id: challenge.owner.playerId, username: challenge.owner.username, socketId: challenge.owner.socketId, trainerSprite: ownerTrainerSprite });
  battleRoom.players.push({ id: challenge.target.playerId, username: challenge.target.username, socketId: challenge.target.socketId, trainerSprite: targetTrainerSprite });

  const playersPayload = [
    sanitizePlayerPayload(challenge.owner.playerPayload, challenge.owner),
    sanitizePlayerPayload(challenge.target.playerPayload, challenge.target),
  ];

  beginBattle(battleRoom, playersPayload, challenge.rules?.seed, challenge.rules);

  sourceRoom.challenges.delete(challenge.id);
  emitChallengeRemoved(sourceRoom, challenge.id, "launched");

  broadcastRoomSummary(battleRoom);
  broadcastRoomSummary(sourceRoom);
}
// Optionally load external Showdown/Essentials datasets at runtime (not bundled)
async function tryLoadExternalData() {
  try {
    const abilities = (await import(path.resolve("external/showdown/abilities.js"))).default;
    if (abilities) mergeAbilities(abilities);
  } catch {}
  try {
    const items = (await import(path.resolve("external/showdown/items.js"))).default;
    if (items) mergeItems(items);
  } catch {}
  // If user placed Showdown-like TS/JS under data/, convert the subset we support
  try {
    const localAbilities = (await import(path.resolve("data/abilities.ts"))).default as Record<string, any>;
    if (localAbilities) mergeAbilities(convertShowdownAbilities(localAbilities));
  } catch {}
  try {
    const localItems = (await import(path.resolve("data/items.ts"))).default as Record<string, any>;
    if (localItems) mergeItems(convertShowdownItems(localItems));
  } catch {}
  try {
    const localSpecies = (await import(path.resolve("data/pokedex.ts"))).default as Record<string, any>;
    if (localSpecies) convertShowdownSpecies(localSpecies);
  } catch {}
  try {
    const localMoves = (await import(path.resolve("data/moves.ts"))).default as Record<string, any>;
    if (localMoves) {
      // Expose moves if needed: for now just convert and keep a map here if you want to serve it.
      convertShowdownMoves(localMoves);
    }
  } catch {}
}
tryLoadExternalData();

const rooms = new Map<string, Room>();
rooms.set(DEFAULT_LOBBY_ID, createRoomRecord(DEFAULT_LOBBY_ID, DEFAULT_LOBBY_NAME));

const FORCE_SWITCH_TIMEOUT_MS = Number(process.env.FORCE_SWITCH_TIMEOUT_MS || 45000);

export function computeNeedsSwitch(state: import("../types").BattleState, engine?: SyncPSEngine): string[] {
  const out: string[] = [];
  for (const pl of state.players) {
    // First check if PS engine says this player needs a force switch
    if (engine && engine.needsForceSwitch(pl.id)) {
      out.push(pl.id);
      continue;
    }
    // Fallback: check our state mirror
    const active = pl.team[pl.activeIndex];
    if (active.currentHP <= 0 && pl.team.some((m, idx) => idx !== pl.activeIndex && m.currentHP > 0)) {
      out.push(pl.id);
    }
  }
  return out;
}

function startForceSwitchTimer(room: Room) {
  clearForceSwitchTimer(room);
  room.forceSwitchDeadline = Date.now() + FORCE_SWITCH_TIMEOUT_MS;
  room.forceSwitchTimer = setTimeout(() => {
    if (!room.engine || !room.forceSwitchNeeded || room.forceSwitchNeeded.size === 0) return;
    // Auto-switch remaining players to first healthy bench
    for (const pid of Array.from(room.forceSwitchNeeded)) {
      const state = room.engine.getState();
      const pl = state.players.find(p => p.id === pid);
      if (!pl) continue;
      const benchIndex = pl.team.findIndex((m, idx) => idx !== pl.activeIndex && m.currentHP > 0);
      if (benchIndex >= 0) {
        const res = room.engine.forceSwitch(pid, benchIndex);
        room.replay.push({ turn: res.state.turn, events: res.events, anim: res.anim, phase: "force-switch", auto: true });
        room.forceSwitchNeeded.delete(pid);
      }
    }
    io.to(room.id).emit("battleUpdate", { result: { state: room.engine.getState(), events: [], anim: [] }, needsSwitch: Array.from(room.forceSwitchNeeded ?? []) });
    if (room.forceSwitchNeeded.size === 0) {
      room.phase = "normal";
      io.to(room.id).emit("phase", { phase: room.phase });
      clearForceSwitchTimer(room);
      // Emit new move prompts so players can choose their next action
      const freshState = room.engine.getState();
      emitMovePrompts(room, freshState);
    } else {
      // Extend time for any still-required (optional). For simplicity, clear deadline and keep old until manual switches.
    }
  }, FORCE_SWITCH_TIMEOUT_MS);
}

function clearForceSwitchTimer(room: Room) {
  if (room.forceSwitchTimer) {
    clearTimeout(room.forceSwitchTimer);
    room.forceSwitchTimer = undefined;
  }
  room.forceSwitchDeadline = undefined;
}

// Turn timeout - disabled auto-fill, just log a warning
// Set TURN_TIMEOUT_MS env var to customize (in milliseconds). Default is 60 seconds.
const TURN_TIMEOUT_MS = Number(process.env.TURN_TIMEOUT_MS || 60000); // 60 seconds default

function startTurnTimer(room: Room) {
  clearTurnTimer(room);
  room.turnDeadline = Date.now() + TURN_TIMEOUT_MS;
  room.turnTimer = setTimeout(() => {
    if (!room.engine || room.phase === "force-switch" || room.phase === "team-preview") return;
    const state = room.engine.getState();
    const expected = state.players.length;
    const submitted = Object.keys(room.turnBuffer);
    if (submitted.length >= expected) return; // Already complete
    
    // Log detailed info about who hasn't submitted - but DO NOT auto-fill
    const missing = state.players.filter(p => !room.turnBuffer[p.id]).map(p => p.id);
    console.warn(`[Server] Turn ${state.turn} timeout - still waiting for ${missing.length} players: ${missing.join(', ')}`);
    console.warn(`[Server] Submitted: ${submitted.join(', ') || 'none'} | Missing: ${missing.join(', ')}`);
    
    // DO NOT auto-fill moves - just continue waiting
    // The battle will only progress when all players submit their actions
    // Restart the timer to keep checking
    startTurnTimer(room);
  }, TURN_TIMEOUT_MS);
}

function clearTurnTimer(room: Room) {
  if (room.turnTimer) {
    clearTimeout(room.turnTimer);
    room.turnTimer = undefined;
  }
  room.turnDeadline = undefined;
}

// Helper to process turn when buffer is full - extracted from sendAction handler
function processTurnWithBuffer(room: Room) {
  if (!room.engine) return;
  const state = room.engine.getState();
  const actions = Object.values(room.turnBuffer);
  room.turnBuffer = {};
  clearTurnTimer(room);
  
  // Filter to only battle actions (move/switch)
  const battleActions = actions.filter((a): a is import("../types").BattleAction => a.type === "move" || a.type === "switch");
  console.log('[Server] Processing turn with actions:', JSON.stringify(battleActions.map(a => ({ type: a.type, pokemonId: a.pokemonId, ...(a.type === 'move' ? { moveId: (a as any).moveId, targetPokemonId: (a as any).targetPokemonId } : {}) }))));
  let result: TurnResult = room.engine.processTurn(battleActions);

  // Deduplicate switch lines (PS sends private + public copies after |split| markers)
  if (Array.isArray(result.events)) {
    result = { ...result, events: deduplicateSwitchLines(result.events) };
  }

  // Filter duplicate start/switch batches after start protocol has already been sent
  if (room.startProtocolSent && Array.isArray(result.events) && result.events.some((l) => l.startsWith("|start"))) {
    const hasActionLine = result.events.some((l) =>
      l.startsWith("|move|") ||
      l.startsWith("|cant|") ||
      l.startsWith("|-damage|") ||
      l.startsWith("|damage|") ||
      l.startsWith("|-heal|") ||
      l.startsWith("|heal|") ||
      l.startsWith("|faint|") ||
      l.startsWith("|-")
    );

    if (!hasActionLine) {
      result = { ...result, events: [], anim: [] };
    } else {
      const initPrefixes = [
        "|start",
        "|teampreview",
        "|clearpoke",
        "|poke|",
        "|player|",
        "|teamsize|",
        "|gen|",
        "|tier|",
        "|gametype|",
        "|t:|",
        "|split|",
      ];
      const filteredEvents = result.events.filter((line) => {
        if (line === "|") return false;
        return !initPrefixes.some((prefix) => line.startsWith(prefix));
      });
      result = { ...result, events: filteredEvents };
    }
  }

  if (!room.startProtocolSent && Array.isArray(result.events) && result.events.some((l) => l.startsWith("|start"))) {
    room.startProtocolSent = true;
  }

  room.replay.push({ turn: result.state.turn, events: result.events, anim: result.anim });
  const needsSwitch: string[] = computeNeedsSwitch(result.state, room.engine instanceof SyncPSEngine ? room.engine : undefined);
  console.log(`[Server] Turn ${result.state.turn} results: events=${result.events.length} needsSwitch=${needsSwitch.length} (${needsSwitch.join(', ')})`);
  if (needsSwitch.length > 0) {
    room.phase = "force-switch";
    room.forceSwitchNeeded = new Set(needsSwitch);
    io.to(room.id).emit("phase", { phase: room.phase, deadline: (room.forceSwitchDeadline = Date.now() + FORCE_SWITCH_TIMEOUT_MS) });
    startForceSwitchTimer(room);
    // Emit force-switch prompts to players who need to switch
    emitForceSwitchPrompts(room, result.state, needsSwitch);
  }
  if (Array.isArray(result?.events)) {
    const hasStart = result.events.some((l) => l === "|start" || l.startsWith("|start|"));
    const hasTurn = result.events.some((l) => l.startsWith("|turn|"));
    const sample = result.events.slice(0, 8);
    console.log(`[DIAG-PROTOCOL] [server] battleUpdate events=${result.events.length} start=${hasStart} turn=${hasTurn} sample=${JSON.stringify(sample)}`);
  } else {
    console.log(`[DIAG-PROTOCOL] [server] battleUpdate events=none`);
  }
  io.to(room.id).emit("battleUpdate", { result, needsSwitch, rooms: { trick: result.state.field.room, magic: result.state.field.magicRoom, wonder: result.state.field.wonderRoom } });
  // Simple end detection: if any player's active mon is fainted and no healthy mons remain
  const sideDefeated = result.state.players.find((pl) => pl.team.every(m => m.currentHP <= 0));
  if (sideDefeated) {
    const winner = result.state.players.find(pl => pl.id !== sideDefeated.id)?.id;
    const replayId = saveReplay(room);
    io.to(room.id).emit("battleEnd", { winner, replayId });
    clearForceSwitchTimer(room);
    clearTurnTimer(room);
  } else if (needsSwitch.length === 0) {
    // Emit new move prompts for the next turn
    emitMovePrompts(room, result.state);
  }
}

io.on("connection", (socket: Socket) => {
  let user: ClientInfo = { id: socket.id, username: `Guest-${socket.id.slice(0, 4)}` };

  socket.on("identify", (data: { username?: string; trainerSprite?: string; avatar?: string }) => {
    if (data?.username) user.username = data.username;
    const nextTrainerSprite = coerceTrainerSprite(data?.trainerSprite ?? data?.avatar);
    if (nextTrainerSprite) user.trainerSprite = nextTrainerSprite;
    const touchedRooms: Room[] = [];
    for (const room of rooms.values()) {
      let touched = false;
      const player = room.players.find((p) => p.socketId === socket.id);
      if (player) {
        player.username = user.username;
        if (user.trainerSprite) player.trainerSprite = user.trainerSprite;
        touched = true;
      }
      const spectator = room.spectators.find((s) => s.socketId === socket.id);
      if (spectator) {
        spectator.username = user.username;
        if (user.trainerSprite) spectator.trainerSprite = user.trainerSprite;
        touched = true;
      }
      if (touched) touchedRooms.push(room);
    }
    socket.emit("identified", { id: user.id, username: user.username, trainerSprite: user.trainerSprite, avatar: user.trainerSprite });
    for (const room of touchedRooms) {
      broadcastRoomSummary(room);
    }
  });

  socket.on("createRoom", (data: { name?: string; id?: string }) => {
    const requestedId = data?.id && typeof data.id === "string" ? data.id.trim() : "";
    const id = requestedId && !rooms.has(requestedId) ? requestedId : uuidv4().slice(0, 8);
    const room = createRoomRecord(id, data?.name || `Room ${id}`);
    rooms.set(id, room);
    socket.join(id);
    socket.emit("roomCreated", { id, name: room.name });
    io.emit("roomUpdate", summary(room));
  });

  socket.on("joinRoom", (data: { roomId: string; role: "player" | "spectator" }) => {
    const room = rooms.get(data.roomId);
    if (!room) return socket.emit("error", { error: "room not found" });
    socket.join(room.id);
    if (data.role === "player") {
      // De-duplicate any stale entries for this user/socket
      room.spectators = room.spectators.filter((s) => s.id !== user.id && s.socketId !== socket.id);
      room.players = room.players.filter((p) => p.socketId !== socket.id || p.id === user.id);
      const existingIndex = room.players.findIndex((p) => p.id === user.id);
      if (existingIndex >= 0) {
        room.players[existingIndex] = {
          ...room.players[existingIndex],
          id: user.id,
          username: user.username,
          socketId: socket.id,
          trainerSprite: user.trainerSprite,
        };
      } else {
        room.players.push({ id: user.id, username: user.username, socketId: socket.id, trainerSprite: user.trainerSprite });
      }
    } else {
      // De-duplicate any stale entries for this user/socket
      room.players = room.players.filter((p) => p.id !== user.id && p.socketId !== socket.id);
      room.spectators = room.spectators.filter((s) => s.socketId !== socket.id || s.id === user.id);
      const existingIndex = room.spectators.findIndex((s) => s.id === user.id);
      if (existingIndex >= 0) {
        room.spectators[existingIndex] = {
          ...room.spectators[existingIndex],
          id: user.id,
          username: user.username,
          socketId: socket.id,
          trainerSprite: user.trainerSprite,
        };
      } else {
        room.spectators.push({ id: user.id, username: user.username, socketId: socket.id, trainerSprite: user.trainerSprite });
      }
      // Send spectator snapshot if battle started
      if (room.battleStarted && room.engine) {
  const state = room.engine.getState();
  socket.emit("spectate_start", { state, replay: room.replay, phase: room.phase ?? "normal", needsSwitch: Array.from(room.forceSwitchNeeded ?? []), deadline: room.forceSwitchDeadline ?? null, rooms: { trick: state.field.room, magic: state.field.magicRoom, wonder: state.field.wonderRoom } });
      }
    }
    io.emit("roomUpdate", summary(room));
    socket.emit("challengeSync", { roomId: room.id, challenges: challengeSummaries(room) });
  });

  socket.on("startBattle", (data: { roomId: string; players: Player[]; seed?: number; rules?: any }) => {
    const room = rooms.get(data.roomId);
    if (!room) return socket.emit("error", { error: "room not found" });
    if (room.battleStarted) return;
    
    const battleSeed = Number.isFinite(data.seed as number) ? (data.seed as number) : undefined;
    if (USE_PS_ENGINE) {
      room.engine = new SyncPSEngine({ format: "gen9customgame", seed: battleSeed, rules: data.rules });
    } else {
      room.engine = new Engine({ seed: battleSeed });
    }

    const hydratedPlayers = data.players.map((player) => {
      const clone = JSON.parse(JSON.stringify(player)) as Player;
      const roomPlayer = room.players.find((p) => p.id === player.id);
      const trainerSprite = coerceTrainerSprite((clone as any).trainerSprite ?? (clone as any).avatar ?? roomPlayer?.trainerSprite);
      (clone as any).trainerSprite = trainerSprite || undefined;
      (clone as any).avatar = trainerSprite || undefined;
      return clone;
    });
    
    const state = room.engine.initializeBattle(hydratedPlayers, { seed: battleSeed });
    if (typeof state.turn === "number" && state.turn < 1) {
      state.turn = 1;
    }
    room.battleStarted = true;
    room.phase = "normal";
    room.forceSwitchNeeded = new Set();
    console.log(`[Server] Emitting battleStarted for room ${room.id} (startBattle socket)`);
    io.to(room.id).emit("battleStarted", { roomId: room.id, state });
    
    // Only verify/inject start events if the engine hasn't already done so
    const hasStart = Array.isArray(state.log) && state.log.some((l: string) => l.startsWith("|start"));
    if (hasStart) room.startProtocolSent = true;
    
    if (!hasStart) {
      const initialEvents = buildInitialBattleProtocol(state);
      if (initialEvents.length > 0) {
        if (Array.isArray(state.log)) {
          for (const line of initialEvents) {
            if (!state.log.includes(line)) state.log.push(line);
          }
        }
        room.startProtocolSent = true;
        io.to(room.id).emit("battleUpdate", {
          result: { state, events: initialEvents, anim: [] },
          needsSwitch: Array.from(room.forceSwitchNeeded ?? []),
        });
      }
    }
    emitMovePrompts(room, state);
  });

  socket.on("sendAction", (data: { roomId: string; playerId: string; action: Action }) => {
    const room = rooms.get(data.roomId);
    if (!room) return socket.emit("error", { error: "room not found" });
    
    // Validate sender is a player in the room and matches playerId
    let sender = room.players.find((p) => p.socketId === socket.id);
    if (!sender || sender.id !== data.playerId) {
      const inRoom = socket.rooms.has(room.id);
      const statePlayer = room.engine?.getState().players.find((p) => p.id === data.playerId);
      if (inRoom && statePlayer) {
        console.warn(`[Server] Recovering missing room player for ${data.playerId} (socket ${socket.id})`);
        // Upsert player record so future prompts/actions have a live socket
        room.players = room.players.filter((p) => p.id !== data.playerId && p.socketId !== socket.id);
        room.players.push({ id: data.playerId, username: statePlayer.name || data.playerId, socketId: socket.id, trainerSprite: (statePlayer as any).trainerSprite });
        sender = room.players.find((p) => p.socketId === socket.id);
      } else {
        return socket.emit("error", { error: "not authorized for this action" });
      }
    }
    
    // Handle team preview phase
    if (room.phase === "team-preview") {
      if (data.action.type === "team" && Array.isArray((data.action as any).order)) {
        console.log(`[Server] Team preview order received from ${data.playerId}:`, (data.action as any).order);
        if (!room.teamPreviewOrders) room.teamPreviewOrders = {};
        room.teamPreviewOrders[data.playerId] = (data.action as any).order;
        socket.emit("teamPreviewSubmitted", { playerId: data.playerId });
        io.to(room.id).emit("teamPreviewProgress", { 
          playerId: data.playerId, 
          submitted: Object.keys(room.teamPreviewOrders).length,
          total: room.teamPreviewPlayers?.length || 2 
        });
        checkTeamPreviewComplete(room);
        return;
      } else if (data.action.type === "auto") {
        // Auto-submit with default order
        if (!room.teamPreviewOrders) room.teamPreviewOrders = {};
        const playerData = room.teamPreviewPlayers?.find(p => p.id === data.playerId);
        const defaultOrder = playerData?.team.map((_: any, i: number) => i + 1) || [1, 2, 3, 4, 5, 6];
        room.teamPreviewOrders[data.playerId] = defaultOrder;
        socket.emit("teamPreviewSubmitted", { playerId: data.playerId });
        io.to(room.id).emit("teamPreviewProgress", { 
          playerId: data.playerId, 
          submitted: Object.keys(room.teamPreviewOrders).length,
          total: room.teamPreviewPlayers?.length || 2 
        });
        checkTeamPreviewComplete(room);
        return;
      }
      return socket.emit("error", { error: "in team preview phase - must submit team order" });
    }
    
    if (!room.engine) return socket.emit("error", { error: "battle not started" });
    // If we're in force-switch phase, only accept switch actions from required players
    if (room.phase === "force-switch") {
      if (!room.forceSwitchNeeded?.has(data.playerId)) {
        return socket.emit("error", { error: "no switch required" });
      }
      if (data.action.type !== "switch") {
        return socket.emit("error", { error: "must switch due to faint" });
      }
      // Validate switch target is not fainted
      const forceSwitchState = room.engine.getState();
      const forceSwitchPlayer = forceSwitchState.players.find(p => p.id === data.playerId);
      if (forceSwitchPlayer) {
        const targetMon = forceSwitchPlayer.team[(data.action as any).toIndex];
        if (!targetMon || targetMon.currentHP <= 0) {
          return socket.emit("error", { error: "cannot switch to a fainted Pokemon" });
        }
        if ((data.action as any).toIndex === forceSwitchPlayer.activeIndex) {
          return socket.emit("error", { error: "cannot switch to the same Pokemon" });
        }
      }
      // Perform immediate forced switch via engine
      let res = room.engine.forceSwitch(data.playerId, (data.action as any).toIndex);
      // Deduplicate switch lines (PS sends private + public copies)
      if (Array.isArray(res.events)) {
        res = { ...res, events: deduplicateSwitchLines(res.events) };
      }
      room.replay.push({ turn: res.state.turn, events: res.events, anim: res.anim, phase: "force-switch" });
      room.forceSwitchNeeded.delete(data.playerId);
      {
        const s = room.engine.getState();
        io.to(room.id).emit("battleUpdate", { result: res, needsSwitch: Array.from(room.forceSwitchNeeded), deadline: room.forceSwitchDeadline ?? null, rooms: { trick: s.field.room, magic: s.field.magicRoom, wonder: s.field.wonderRoom } });
      }
      if (room.forceSwitchNeeded.size === 0) {
        room.phase = "normal";
        io.to(room.id).emit("phase", { phase: room.phase });
        clearForceSwitchTimer(room);
        // Emit new move prompts so players can choose their next action
        const freshState = room.engine.getState();
        emitMovePrompts(room, freshState);
      }
      return;
    }
    // Validate switch actions before buffering
    if (data.action.type === "switch") {
      const normalState = room.engine.getState();
      const normalPlayer = normalState.players.find(p => p.id === data.playerId);
      if (normalPlayer) {
        const targetMon = normalPlayer.team[(data.action as any).toIndex];
        if (!targetMon || targetMon.currentHP <= 0) {
          return socket.emit("error", { error: "cannot switch to a fainted Pokemon" });
        }
        if ((data.action as any).toIndex === normalPlayer.activeIndex) {
          return socket.emit("error", { error: "cannot switch to the same Pokemon" });
        }
      }
    }
    
    // Convert moveIndex-based action to moveId-based action
    // Client may send { type: 'move', moveId: '...', moveIndex: 0 }
    let processedAction = data.action;
    if (data.action.type === "move") {
      const moveState = room.engine.getState();
      const movePlayer = moveState.players.find(p => p.id === data.playerId);
      if (movePlayer) {
        const activePokemon = movePlayer.team[movePlayer.activeIndex];
        const opponent = moveState.players.find(p => p.id !== data.playerId);
        const opponentActive = opponent?.team[opponent.activeIndex];

        const providedMoveId = (data.action as any).moveId as string | undefined;
        const moveIndex = (data.action as any).moveIndex as number | undefined;
        const moveFromIndex = typeof moveIndex === "number" ? activePokemon?.moves?.[moveIndex] : undefined;
        const resolvedMoveId = providedMoveId || (moveFromIndex ? (typeof moveFromIndex === 'string' ? moveFromIndex : (moveFromIndex.id || moveFromIndex.name)) : undefined);

        if (resolvedMoveId) {
          processedAction = {
            type: "move",
            actorPlayerId: data.playerId,
            pokemonId: activePokemon.id,
            moveId: resolvedMoveId,
            targetPlayerId: opponent?.id || "",
            targetPokemonId: opponentActive?.id || "",
            mega: !!(data.action as any).mega,
            zmove: !!(data.action as any).zmove,
            dynamax: !!(data.action as any).dynamax,
            terastallize: !!(data.action as any).terastallize,
          } as MoveAction;
          if (typeof moveIndex === "number") {
            console.log(`[Server] Converted moveIndex ${moveIndex} to moveId ${resolvedMoveId}`);
          } else {
            console.log(`[Server] Using provided moveId ${resolvedMoveId}`);
          }
        }
      }
    }
    
    // Handle switch action - client may send switchTo or toIndex
    if (data.action.type === "switch") {
      const switchState = room.engine.getState();
      const switchPlayer = switchState.players.find(p => p.id === data.playerId);
      if (switchPlayer) {
        const activePokemon = switchPlayer.team[switchPlayer.activeIndex];
        // Support both switchTo (legacy) and toIndex
        const targetIndex = (data.action as any).toIndex ?? (data.action as any).switchTo;
        
        processedAction = {
          type: "switch",
          actorPlayerId: data.playerId,
          pokemonId: activePokemon?.id || "",
          toIndex: targetIndex,
        } as SwitchAction;
        console.log(`[Server] Processed switch action to index ${targetIndex}`);
      }
    }
    
    room.turnBuffer[data.playerId] = processedAction;
    console.log(`[Server] Action received from ${data.playerId}:`, JSON.stringify(processedAction));
    const currentState = room.engine.getState();
    const expected = currentState.players.length;

    // Log disconnected players but DO NOT auto-fill their actions
    const livePlayerIds = new Set(
      room.players.filter((p) => io.sockets.sockets.has(p.socketId)).map((p) => p.id)
    );
    const missingPlayers = currentState.players.filter((p) => !livePlayerIds.has(p.id));
    if (missingPlayers.length > 0) {
      console.warn(`[Server] Disconnected players: ${missingPlayers.map(p => p.id).join(', ')} - waiting for reconnection or timeout`);
    }

    console.log(`[Server] Turn buffer size: ${Object.keys(room.turnBuffer).length}/${expected}`);
    if (Object.keys(room.turnBuffer).length >= expected) {
      processTurnWithBuffer(room);
    } else {
      // Send "waiting" notification ONLY to the player who just submitted
      // Not to all players - that would incorrectly put both in waiting state
      socket.emit("promptAction", { 
        roomId: data.roomId,
        playerId: data.playerId,
        waitingFor: expected - Object.keys(room.turnBuffer).length,
        prompt: { wait: true }
      });
    }
  });

  socket.on("sendChat", (data: { roomId: string; text: string }) => {
    const room = rooms.get(data.roomId);
    if (!room) return;
    io.to(room.id).emit("chatMessage", { user: user.username, text: data.text, time: Date.now() });
  });

  socket.on("createChallenge", (data: { roomId: string; challengeId?: string; toPlayerId?: string; rules?: any; format?: string; player?: Player }) => {
    const room = data?.roomId ? rooms.get(data.roomId) : undefined;
    if (!room) return socket.emit("error", { error: "room not found" });
    const isPlayer = Boolean(findPlayerBySocket(room, socket.id));
    if (!isPlayer) return socket.emit("error", { error: "must join as player" });

    const rawId = typeof data?.challengeId === "string" ? data.challengeId.trim() : "";
    const challengeId = rawId && !room.challenges.has(rawId) ? rawId : uuidv4().slice(0, 8);
    const targetPlayer = data?.toPlayerId ? room.players.find((p) => p.id === data.toPlayerId) : undefined;

    const ownerPayload = data?.player ? JSON.parse(JSON.stringify(data.player)) : undefined;
    const ownerTrainerSprite = coerceTrainerSprite((ownerPayload as any)?.trainerSprite ?? (ownerPayload as any)?.avatar ?? user.trainerSprite);
    if (ownerPayload && ownerTrainerSprite) {
      (ownerPayload as any).trainerSprite = ownerTrainerSprite;
      (ownerPayload as any).avatar = ownerTrainerSprite;
    }

    const challenge: Challenge = {
      id: challengeId,
      roomId: room.id,
      createdAt: Date.now(),
      rules: data?.rules,
      format: data?.format,
      status: "pending",
      owner: {
        playerId: user.id,
        username: user.username,
        socketId: socket.id,
        accepted: true,
        trainerSprite: ownerTrainerSprite,
        playerPayload: ownerPayload,
      },
      target: targetPlayer
        ? {
            playerId: targetPlayer.id,
            username: targetPlayer.username,
            socketId: targetPlayer.socketId,
            accepted: false,
          }
        : undefined,
      open: !targetPlayer,
    };

    room.challenges.set(challenge.id, challenge);
    emitChallengeCreated(room, challenge);
    broadcastRoomSummary(room);
  });

  socket.on("cancelChallenge", (data: { roomId: string; challengeId: string }) => {
    const room = data?.roomId ? rooms.get(data.roomId) : undefined;
    if (!room) return;
    const challenge = data?.challengeId ? room.challenges.get(data.challengeId) : undefined;
    if (!challenge) return;
    if (challenge.owner.socketId !== socket.id) return socket.emit("error", { error: "not authorized" });
    room.challenges.delete(challenge.id);
    emitChallengeRemoved(room, challenge.id, "cancelled");
    broadcastRoomSummary(room);
  });

  socket.on("respondChallenge", (data: { roomId: string; challengeId: string; accepted: boolean; player?: Player }) => {
    const room = data?.roomId ? rooms.get(data.roomId) : undefined;
    if (!room) return socket.emit("error", { error: "room not found" });
    const challenge = data?.challengeId ? room.challenges.get(data.challengeId) : undefined;
    if (!challenge) return socket.emit("error", { error: "challenge not found" });

    let participant: ChallengeParticipant | undefined;
    if (challenge.owner.socketId === socket.id) participant = challenge.owner;
    if (!participant && challenge.target && challenge.target.socketId === socket.id) participant = challenge.target;

    if (!participant && challenge.open && data?.accepted) {
      // Claim the open challenge
      challenge.target = {
        playerId: user.id,
        username: user.username,
        socketId: socket.id,
        accepted: false,
      };
      challenge.open = false;
      participant = challenge.target;
    }

    if (!participant) return socket.emit("error", { error: "not part of challenge" });

    if (!data?.accepted) {
      room.challenges.delete(challenge.id);
      emitChallengeRemoved(room, challenge.id, "declined");
      broadcastRoomSummary(room);
      return;
    }

    if (!data?.player) return socket.emit("error", { error: "team payload required" });

    const participantPayload = JSON.parse(JSON.stringify(data.player));
    const participantTrainerSprite = coerceTrainerSprite((participantPayload as any)?.trainerSprite ?? (participantPayload as any)?.avatar ?? user.trainerSprite);
    if (participantTrainerSprite) {
      (participantPayload as any).trainerSprite = participantTrainerSprite;
      (participantPayload as any).avatar = participantTrainerSprite;
    }
    participant.accepted = true;
    participant.username = user.username;
    participant.trainerSprite = participantTrainerSprite;
    participant.playerPayload = participantPayload;

    if (challenge.owner.accepted && challenge.owner.playerPayload && challenge.target && challenge.target.accepted && challenge.target.playerPayload) {
      challenge.status = "launching";
      emitChallengeUpdated(room, challenge);
      launchChallenge(room, challenge);
    } else {
      emitChallengeUpdated(room, challenge);
    }
  });

  socket.on("disconnect", () => {
    // Remove from any rooms
    for (const room of rooms.values()) {
      const removed = removeClientFromRoom(room, socket.id);
      if (removed) {
        // Clean up challenges involving this socket
        for (const challenge of Array.from(room.challenges.values())) {
          if (challenge.owner.socketId === socket.id) {
            room.challenges.delete(challenge.id);
            emitChallengeRemoved(room, challenge.id, "creator-left");
          } else if (challenge.target && challenge.target.socketId === socket.id) {
            challenge.target = undefined;
            challenge.open = true;
            challenge.status = "pending";
            emitChallengeUpdated(room, challenge);
          }
        }
        broadcastRoomSummary(room);
      }

      const isEmpty = room.players.length === 0 && room.spectators.length === 0;
      if (isEmpty && room.id !== DEFAULT_LOBBY_ID) {
        rooms.delete(room.id);
        io.emit("roomRemoved", { id: room.id });
      }
    }
  });
});

function summary(room: Room) {
  return {
    id: room.id,
    name: room.name,
    players: room.players.map((p) => ({ id: p.id, username: p.username, trainerSprite: p.trainerSprite, avatar: p.trainerSprite })),
    spectCount: room.spectators.length,
    battleStarted: room.battleStarted,
    challengeCount: room.challenges.size,
  };
}

function saveReplay(room: Room) {
  const id = uuidv4().slice(0, 8);
  const file = path.join(REPLAYS_DIR, `${id}.json`);
  const payload = {
    id,
    room: { id: room.id, name: room.name },
    createdAt: Date.now(),
    replay: room.replay,
  };
  fs.writeFileSync(file, JSON.stringify(payload, null, 2));
  return id;
}

export function startServer(port = Number(process.env.PORT) || 3000) {
  server.listen(port, () => console.log(`Server running on :${port}`));
}

if (require.main === module) {
  startServer();
}
